---
layout: post
title: NuGet Servers, HBase, Thrift Code Generation and one sweet Jenkins CI Build
date: '2014-04-26T23:21:00.005-07:00'
author: William Berry
tags:
- Automation
- NTLM
- Build Pipeline
- NuGet
- Continuous Integration
- Jenkins
- ProGet
modified_time: '2014-04-26T23:23:50.561-07:00'
thumbnail: http://3.bp.blogspot.com/-xzJFMfVgMs8/U1wpZjkQvyI/AAAAAAAAARw/2nhM2agjsLQ/s72-c/SnipImage+copy+4.JPG
blogger_id: tag:blogger.com,1999:blog-4707687462195457004.post-3115882263462139722
blogger_orig_url: http://www.lucidmotions.net/2014/04/nuget-code-generation-jenkins-thrift-hbase.html
---

Its always a bit of a joy when pet and client projects align on similar goals, the proverbial 'killing of two birds with one stone'. &nbsp;Admittedly though, I applied a touch of coercion to get these in sync.<br /><div><br /></div><div>The client project:&nbsp;</div><div><ul><li>HBase Thrift connector in C#, which has a code generation step to convert the HBase thrift file into a C# lib.</li></ul>The pet project(s):&nbsp;</div><div><ul><li>Internal NuGet Server</li><li>Scripts for Jenkins to run a code generation process</li><li>Scripts for Jenkins to build NuGet packages</li><li>Programmatically building a C# Visual Studio project</li></ul>Though it is not the specific focus of this post, I will lightly cover the HBase thrift connector for those that are interested. &nbsp;So without further adieu, lets get to work…</div><h3>Step 1 - Build the NuGet Server</h3><div>I screwed around for a while with the NuGet package that lets you build your own self hosted server. &nbsp;For those that have the unnatural desire to tweak all the nobs … try it out. &nbsp;I admit, I gave up very early in the process after realizing I could:</div><div><ol><li>Use a pre-baked solution that was a snap to install and configure.</li><li>Throw money at someone when our dependency on the product finally warranted support.</li></ol><div><a href="http://inedo.com/proget/overview" target="_blank">ProGet (from Inedo)</a>&nbsp;was a great fit. &nbsp;Product is a snap to install, and configure. &nbsp;I simply set up an IIS website as follows:&nbsp;</div></div><div><ol><li>Define a default localhost:port binding (this was configured when installing the product).</li><li>Define a redirect binding of nuget.{server}.{domain}.com to the localhost setup.</li><li>Under the site's authentication settings, enable Windows Authentication, disable anonymous, remove the Negotiate provider from the Windows Authentication provider.</li><li>Under authorization rules, add an entry for your group as "allow".&nbsp;</li><li>Ping your IT/Active Directory team to add the redirect url to the groups trusted sites list.</li></ol><div>In our department, we primarily use IE and Chrome, both honor the GPO trusted sites list though the setting does not always stick the first time through. &nbsp;If that's the case for you, and the site is asking for authentication, be sure to kill IE &amp; Chrome, run a "gpupdate /force", then log out and back in again … it *should* work now. <br /><br />Lastly, NuGet Package Manager in Visual Studio works seamlessly with Windows NTLM Authentication. &nbsp;With the site running, you now have a group authenticated, nominally secured internally hosted NuGet Server. &nbsp;I think that deserves a "Sweet, Right On!"</div><div><br /></div><h3>Step 2 - Configure NuGet</h3><div>We have a few things to configure to get NuGet up and running after installation. &nbsp;The developer's workstations will need to be patched to the new server so they can find your internally hosted packages and all build machines, plus their slaves, will need an additional configuration file.</div><div><br /></div><div>First things first, lets get the URL for our new server; this had me stumped for a bit. &nbsp;Visit your new site in your browser of choice, select "Browse Packages" and then click on the RSS Feed button on the presented page.</div><div><br /></div><div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-xzJFMfVgMs8/U1wpZjkQvyI/AAAAAAAAARw/2nhM2agjsLQ/s1600/SnipImage+copy+4.JPG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://3.bp.blogspot.com/-xzJFMfVgMs8/U1wpZjkQvyI/AAAAAAAAARw/2nhM2agjsLQ/s1600/SnipImage+copy+4.JPG" height="96" width="400" /></a></div><div><br /></div><div>You will be presented with a page that has the Atom XML data, just grab the Url and fire up Visual Studio.</div><div><br /></div><div>The Visual Studio changes are a snap. &nbsp;Under <i>Tools</i> -&gt; <i>NuGet Package Manager</i>, select "<i>Manage NuGet Packages for Solution</i>." &nbsp;You will be presented with the hopefully familiar screen:</div><div><br /></div><div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-Pyvthj9PqLc/U1wqTVQ-E1I/AAAAAAAAAR4/NqftVA0BTLI/s1600/SnipImage+copy+2.JPG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://3.bp.blogspot.com/-Pyvthj9PqLc/U1wqTVQ-E1I/AAAAAAAAAR4/NqftVA0BTLI/s1600/SnipImage+copy+2.JPG" height="265" width="400" /></a></div><div><br /></div><div>Clicking on <i>Settings</i> in the lower left corner will bring you to the Visual Studio "<i>Options</i>" Window with <i>Package Sources</i> Settings in focus.</div><div><br /></div><div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-BKeGoAsUhWY/U1wq5vSpcbI/AAAAAAAAASA/WMrfD-sqsOI/s1600/SnipImage+copy+3.JPG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://3.bp.blogspot.com/-BKeGoAsUhWY/U1wq5vSpcbI/AAAAAAAAASA/WMrfD-sqsOI/s1600/SnipImage+copy+3.JPG" height="322" width="400" /></a></div><div><br /></div><div>In the upper right corner click the "<i>+</i>" button and add the url you copied from your browser earlier, and a name for your new NuGet Server. &nbsp;Select "<i>OK</i>."</div><div><br /></div><div>The next point to address is configuring the Build Server(s) and any slaves that perform NuGet Package Restores. &nbsp;</div><div><br /></div><div>For almost all of our projects, we enable Nuget Package Restore. &nbsp;This can be done by adding the following markup in your Nant target right before the call to MS Build.<br /><br /></div><div></div><pre><span style="color: #a65700;">&lt;</span><span style="color: #5f5035;">setenv</span><span style="color: #a65700;">&gt;</span>  <br />    <span style="color: #a65700;">&lt;</span><span style="color: #5f5035;">variable</span> <span style="color: #274796;">name</span><span style="color: #808030;">=</span><span style="color: #0000e6;">"</span><span style="color: #0000e6;">EnableNuGetPackageRestore</span><span style="color: #0000e6;">"</span> <span style="color: #274796;">value</span><span style="color: #808030;">=</span><span style="color: #0000e6;">"</span><span style="color: #0000e6;">true</span><span style="color: #0000e6;">"</span> <span style="color: #a65700;">/&gt;</span>  <br /><span style="color: #a65700;">&lt;/</span><span style="color: #5f5035;">setenv</span><span style="color: #a65700;">&gt;</span><br /></pre><pre><span style="color: #a65700;"><br /></span></pre><div>No matter which NuGet executable is called, the one included in your project or one installed on the host itself, the program can use a global config file located in "C:\ProgramData\NuGet". &nbsp;Create the NuGet folder if it does not exist and add a file called <i>NuGetDefaults.config</i>. &nbsp;You can Google plenty of resources on what can go in this file; but, what is essential is the following markup:<br /><br /></div><div><pre><span style="color: #004a43;">&lt;?</span><span style="color: maroon; font-weight: bold;">xml</span><span style="color: #004a43;"> </span><span style="color: #074726;">version</span><span style="color: #808030;">=</span><span style="color: #0000e6;">"</span><span style="color: #7d0045;">1.0</span><span style="color: #0000e6;">"</span><span style="color: #004a43;"> </span><span style="color: #074726;">encoding</span><span style="color: #808030;">=</span><span style="color: #0000e6;">"</span><span style="color: #0000e6;">UTF-8</span><span style="color: #0000e6;">"</span><span style="color: #004a43;">?&gt;</span>  <br /><span style="color: #a65700;">&lt;</span><span style="color: #5f5035;">configuration</span><span style="color: #a65700;">&gt;</span>    <br />    <span style="color: #a65700;">&lt;</span><span style="color: #5f5035;">packageSources</span><span style="color: #a65700;">&gt;</span>  <br />        <span style="color: #a65700;">&lt;</span><span style="color: #5f5035;">add</span> <span style="color: #274796;">key</span><span style="color: #808030;">=</span><span style="color: #0000e6;">"</span><span style="color: #0000e6;">nuget.org</span><span style="color: #0000e6;">"</span>&nbsp;</pre><pre><span style="color: #274796;">             value</span><span style="color: #808030;">=</span><span style="color: #0000e6;">"</span><span style="color: #0000e6;">https://www.nuget.org/api/v2/</span><span style="color: #0000e6;">"</span> <span style="color: #a65700;">/&gt;</span>  <br />        <span style="color: #a65700;">&lt;</span><span style="color: #5f5035;">add</span> <span style="color: #274796;">key</span><span style="color: #808030;">=</span><span style="color: #0000e6;">"</span><span style="color: #0000e6;">Nuget Source</span><span style="color: #0000e6;">"</span>&nbsp;</pre><pre><span style="color: #274796;">             value</span><span style="color: #808030;">=</span><span style="color: #0000e6;">"</span><span style="color: #0000e6;">http://nuget.myserver.com/nuget/NugetFeed</span><span style="color: #0000e6;">"</span> <span style="color: #a65700;">/&gt;</span>  <br />    <span style="color: #a65700;">&lt;/</span><span style="color: #5f5035;">packageSources</span><span style="color: #a65700;">&gt;</span>  <br /><span style="color: #a65700;">&lt;/</span><span style="color: #5f5035;">configuration</span><span style="color: #a65700;">&gt;</span><br /></pre><pre><span style="color: #a65700;"><br /></span></pre></div></div><div>The markup here simply adds the sources that the build server may restore packages from; in this case both <a href="http://nuget.org/">nuget.org</a> and our internal site.</div><div><br /></div><div>NOTE: <i>there are some pretty slick options when it comes to ProGet which you should look into. &nbsp;You can have your local server act as a proxy for nuget.org and filter out packages with licenses that are incompatible with your environment. &nbsp;Obviously it does not keep a dev from subverting legal requirements by simply including a package with the source commit; but, it can help stop accidental usage.</i></div><div><br /></div><div>With our config file set up on the build server(s) and the dev environments patched, we can turn our attention back to getting our first package up on the new NuGet server.</div><div><br /></div><h3>Step 3 - Thrift C# Code Generation</h3><div>Though its a bit of a tangent to the core of this post, I am going to use the building of the C# classes for a Thrift to HBase connector as the example.</div><div><br /></div><div>Our first step is to set up a blank, no frills Visual Studio class library project. &nbsp;Once that's up, go into the NuGet Package Manager and import the "Thrift" package by the <i>Apache Software Foundation</i>. &nbsp;As of the writing of this article the version is <i>0.9.1.3</i>. &nbsp;There are really only two important things in this package:</div><div><ol><li>A precompiled Windows Thrift compiler, <i>thrift.exe</i>.</li><li>The <i>Thrift.dll</i> which you will provide the common implementation code for your thrift interface.</li></ol><div>NOTE: <i>quite obviously, both of these projects are publicly available. &nbsp;Though there is some complexity to compiling them yourself, you could for example, set up Jenkins to poll the github repository, scrape the tags on master, pull the most recent branch, version and build both the compiler and the core thrift.dll, posting the output automatically to your NuGet server. &nbsp;You *COULD* do that; but personally, I would rather just link the existing thrift NuGet package.</i></div></div><div><br /></div><div>With the thrift NuGet package pulled into out project we are only missing the base.thrift file from the trunk of the apache HBase project, found <a href="http://svn.apache.org/viewvc/hbase/trunk/hbase-thrift/src/main/resources/org/apache/hadoop/hbase/thrift/Hbase.thrift?view=markup" target="_blank">here</a>. &nbsp;Pull this file into a folder in your project, I put it under CodeGen\ThriftFiles. &nbsp;</div><div><br /></div><div>One stupid note about this file. &nbsp;As with most cross platform GitHub projects the line endings can be nearly random. &nbsp;As of the writing of this post, they are old school Mac '\r', which may or may not screw things up. &nbsp;Regardless, you will see in the code generation script that I normalize the file to Windows' line endings as a precaution.&nbsp;</div><div><br /></div><div>We will be writing a PowerShell script to accomplish the code generation. &nbsp;You can obviously use what ever you like. &nbsp;I selected PowerShell … <i>because</i>. &nbsp;Nuff-said and no comments on this from the peanut gallery.&nbsp;</div><div><br /></div><div>The basic flow of our script is as follows:</div><div><ol><li>Clean the line endings of the thrift file.</li><li>Create the output folder if it does not exist, if it does clean it.</li><li>Pass the hbase.thrift file into the thrift compiler and generate the C# classes.</li><li>Get the names of all the generated files.</li><li>Open the .csproj file, select any existing nodes to remove and add the generated files.</li><li>Save the .csproj file.</li></ol><div>NOTE: &nbsp;<i>I do not claim any responsibility for the code I am about to present. &nbsp;As a recent migrant to PowerShell, I am putting myself and my code out there without warranties or promisses that it is either A) written well or B) even remotely how it should be done. &nbsp;I so encourage commentary from the peanut gallery on this, if there is any. &nbsp;I do appreciate learning how things could/should be done correctly.</i><br /><i><br /></i></div></div><div>Let's start by setting up some variables:<br /><br /></div><div><pre><span style="color: teal;">  1</span> <span style="color: #35687d;">$ErrorActionPreference</span> = <span style="color: maroon;">"Stop"</span>   <br /><span style="color: teal;">  2</span> <span style="color: #35687d;">$TargetDir</span>             = <span style="color: maroon;">'.\src\ThriftInterface\autogen\'</span> <br /><span style="color: teal;">  3</span> <span style="color: #35687d;">$ThriftExecutable</span>      = <span style="color: maroon;">'.\src\packages\Thrift.0.9.1.3\tools\thrift-0.9.1.exe'</span>  <br /><span style="color: teal;">  4</span> <span style="color: #35687d;">$HBaseThriftFile</span>       = <span style="color: maroon;">'.\src\CodeGeneration\ThriftFiles\hbase.thrift'</span> <br /><span style="color: teal;">  5</span> <span style="color: #35687d;">$Language</span>              = <span style="color: maroon;">'csharp'</span> </pre><br /></div><div>Fix the line endings in the thrift file as noted earlier:<br /><br /></div><div><pre><span style="color: teal;">  1</span> (<span style="color: #2b91af;">Get-Content</span> <span style="color: #35687d;">$BaseThriftFile</span>) |   <br /><span style="color: teal;">  2</span>          <span style="color: blue;">Foreach</span>-Object {   <br /><span style="color: teal;">  3</span>                  <span style="color: #35687d;">$_</span> -replace <span style="color: maroon;">'`r`n'</span> , <span style="color: maroon;">'`r'</span> -replace <span style="color: maroon;">'`n'</span> , <span style="color: maroon;">'`r'</span>   <br /><span style="color: teal;">  4</span>          } |   <br /><span style="color: teal;">  5</span>          <span style="color: #2b91af;">Set-Content</span> <span style="color: #35687d;">$BaseThriftFile</span></pre><pre></pre></div><div>Create the target output folder if it does not exist, clear its contents either way:<br /><br /></div><div><pre><span style="color: teal;">  1</span> <span style="color: #2b91af;">Write-Host</span> <span style="color: maroon;">"Checking for existance of $TargetDir"</span>   <br /><span style="color: teal;">  2</span> <span style="color: blue;">if</span>(!(<span style="color: #2b91af;">Test-Path</span> -Path <span style="color: #35687d;">$TargetDir</span> )){   <br /><span style="color: teal;">  3</span>     <span style="color: #2b91af;">Write-Host</span> <span style="color: maroon;">"Target does not exist, creating $TargetDir"</span>   <br /><span style="color: teal;">  4</span>     <span style="color: #2b91af;">New-Item</span> -ItemType directory -Path <span style="color: #35687d;">$TargetDir</span>   <br /><span style="color: teal;">  5</span> }   <br /><span style="color: teal;">  6</span>    <br /><span style="color: teal;">  7</span> <span style="color: #2b91af;">Write-Host</span> <span style="color: maroon;">"Clearing contents of $TargetDir"</span>   <br /><span style="color: teal;">  8</span> <span style="color: #35687d;">$tardir</span> = <span style="color: #35687d;">$TargetDir</span> + <span style="color: maroon;">'\*.*'</span>  <br /><span style="color: teal;">  9</span> <span style="color: #2b91af;">Remove-Item</span> <span style="color: #35687d;">$tardir</span> -recurse -force&nbsp;</pre><br /></div><div>Pass the cleansed file into the thrift compiler, specify the target language and direct the output:<br /><br /></div><div><pre><span style="color: teal;">  1</span> <span style="color: #2b91af;">Write-Host</span> <span style="color: maroon;">"Begining code generation phase; output set to $TargetDir"</span>   <br /><span style="color: teal;">  2</span> <span style="color: #35687d;">$arguments</span> = <span style="color: maroon;">"-out $TargetDir --gen $Language $BaseThriftFile"</span>   <br /><span style="color: teal;">  3</span> <span style="color: #2b91af;">Invoke-Expression</span> <span style="color: maroon;">"$ThriftExecutable $arguments"</span>   <br /><span style="color: teal;">  4</span> <span style="color: #2b91af;">Write-Host</span> <span style="color: maroon;">"Finding Auto-generated Code in Directory: $TargetDir"</span>   <br /><span style="color: teal;">  5</span> <span style="color: #35687d;">$tardir</span> = <span style="color: #35687d;">$TargetDir</span> + <span style="color: maroon;">'\HBase\*.*'</span> <span style="color: green;"># HBase is the namespace  </span><br /><span style="color: teal;">  6</span> <span style="color: #35687d;">$autogenFileNames</span> = <span style="color: #2b91af;">Get-ChildItem</span> <span style="color: #35687d;">$tardir</span> |    <br /><span style="color: teal;">  7</span>                     <span style="color: blue;">Where</span>-Object {<span style="color: #35687d;">$_</span>.Extension -eq <span style="color: maroon;">".cs"</span>} </pre><br /></div><div>Read the .csproj file into a variable:<br /><br /></div><div><pre><span style="color: teal;">  1</span> <span style="color: #35687d;">$proj</span> = [xml](<span style="color: #2b91af;">get-content</span>&nbsp;</pre><pre>                 (<span style="color: #2b91af;">Resolve-Path</span> <span style="color: maroon;">'.\src\ThriftInterface\ThriftInterface.csproj'</span>))</pre><br /></div><div>Typically most project files only have one compile Item Group definition. &nbsp;We will want access to that node later for the additions, so select it into a variable. &nbsp;Then find any existing auto-generated file nodes and remove them.<br /><br /></div><div><pre><span style="color: teal;">  1</span> <span style="color: #35687d;">$ParentNode</span> =  <span style="color: #35687d;">$proj</span>.Project.ItemGroup.Compile.ParentNode | <br /><span style="color: teal;">  2</span>                <span style="color: #2b91af;">Select-Object</span> -First <span style="color: maroon;">1</span>   <br /><span style="color: teal;">  3</span> <span style="color: #35687d;">$removeElements</span> = <span style="color: #35687d;">$proj</span>.Project.ItemGroup.Compile |  <br /><span style="color: teal;">  4</span>                   ? { <span style="color: #35687d;">$_</span>.Include -Match <span style="color: maroon;">"autogen"</span> }<br /><span style="color: teal;">  5</span> <span style="color: blue;">if</span> (<span style="color: #35687d;">$removeElements</span>) { <span style="color: #35687d;">$removeElements</span> | <br /><span style="color: teal;">  6</span>                        % { <span style="color: #35687d;">$_</span>.ParentNode.RemoveChild(<span style="color: #35687d;">$_</span>) } <br /><span style="color: teal;">  7</span>                      } </pre><br /></div><div>Finally, we want to loop the folder where the compiler put the generated code, add those files into the compile item group and save the project file.<br /><br /></div><div><pre><span style="color: teal;">  1</span> <span style="color: blue;">foreach</span> (<span style="color: #35687d;">$fileName</span> <span style="color: blue;">in</span> <span style="color: #35687d;">$autogenFileNames</span>.Name) {  <br /><span style="color: teal;">  2</span>          <span style="color: #35687d;">$xmlElt</span> = <span style="color: #35687d;">$proj</span>.CreateElement(<span style="color: maroon;">"Compile"</span>, <span style="color: #35687d;">$nameSpace</span>)   <br /><span style="color: teal;">  3</span>          <span style="color: #35687d;">$xmlAtt</span> = <span style="color: #35687d;">$proj</span>.CreateAttribute(<span style="color: maroon;">"Include"</span>)   <br /><span style="color: teal;">  4</span>          <span style="color: #35687d;">$xmlAtt</span>.Value = <span style="color: maroon;">"autogen\Hbase\$fileName"</span>   <br /><span style="color: teal;">  5</span>          <span style="color: #35687d;">$xmlElt</span>.Attributes.Append(<span style="color: #35687d;">$xmlAtt</span>)  <br /><span style="color: teal;">  6</span>          <span style="color: #35687d;">$ParentNode</span>.AppendChild(<span style="color: #35687d;">$xmlElt</span>)  <br /><span style="color: teal;">  7</span> }   <br /><span style="color: teal;">  8</span>    <br /><span style="color: teal;">  9</span> <span style="color: #35687d;">$proj</span>.Save((<span style="color: #2b91af;">Resolve-Path</span> <span style="color: maroon;">".\src\ThriftInterface\ThriftInterface.csproj"</span>))   <br /><span style="color: teal;"> 10</span> exit </pre><br /></div><div>So there you have it. &nbsp;In 30 lines of code we have converted a .thrift file into a functioning Visual Studio Project!<br /><br /></div><div><h3>Step 4 - Script NuGet Package Creation</h3></div><div>Our next task is to create a light script that can wrap up our project into a NuGet package. This requires all of about 8 lines of code.<br /><br /></div><div><pre><span style="color: teal;">  1</span> <span style="color: #35687d;">$ErrorActionPreference</span> = <span style="color: maroon;">"Stop"</span>   <br /><span style="color: teal;">  2</span> <span style="color: #35687d;">$curpath</span>= <span style="color: maroon;">".\src\ThriftInterface\"</span>  <br /><span style="color: teal;">  3</span> <span style="color: #35687d;">$projectName</span>= <span style="color: maroon;">"ThriftInterface.csproj"</span>  <br /><span style="color: teal;">  4</span>  <br /><span style="color: teal;">  5</span> NuGet Pack <span style="color: maroon;">"$curpath$projectName"</span> -Properties Configuration=Release -OutputDirectory <span style="color: #35687d;">$curpath</span> <br /><span style="color: teal;">  6</span>  <br /><span style="color: teal;">  7</span> <span style="color: #35687d;">$package</span> = @(<span style="color: #2b91af;">Get-ChildItem</span> <span style="color: #35687d;">$curpath</span> -include *.nupkg -recurse | <span style="color: #2b91af;">Sort-Object</span>)  <br /><span style="color: teal;">  8</span> <span style="color: #35687d;">$key</span> = <span style="color: maroon;">"*********************"</span>  <br /><span style="color: teal;">  9</span>  <br /><span style="color: teal;"> 10</span> nuget push -Source <span style="color: maroon;">"http://nuget.myserver.com/nuget/TreNugetFeed"</span> <span style="color: #35687d;">$package</span>[-<span style="color: maroon;">1</span>] <span style="color: #35687d;">$key</span>   <br /><span style="color: teal;"> 11</span> exit  </pre><br /></div><div>The script sets up some locals, runs <i>nuget pack</i> on the project with the proper build settings and calls <i>nuget push</i> on the package with the Api key to the NuGet server url. <br /><br /></div><h3>Step 5 - Put It All Together With Jenkins</h3>Final step here is to wrap the whole project up with a Jenkins job. &nbsp;We need to commit our project shell to source control: Git/HG/SVN. Whatever works. &nbsp;All of our projects include a moderately stock Nant script that sets up package structure for the binaries; which we will run in this example. &nbsp;Even though the NuGet script in Step 4 also performs a build, the Nant build will generate the artifacts for the binary repository. &nbsp;And there is no real issue with building it twice.<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-EEf0j0jnxwU/U1xKbc12VQI/AAAAAAAAASQ/MLlSfDhzNpQ/s1600/SnipImage.JPG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://4.bp.blogspot.com/-EEf0j0jnxwU/U1xKbc12VQI/AAAAAAAAASQ/MLlSfDhzNpQ/s1600/SnipImage.JPG" height="286" width="640" /></a></div><br />Under the build in Jenkins we will configure the execution of out code generation script. &nbsp;Since the PowerShell script is not yet signed, we need to set the execution policy to unrestricted. <br /><br /><div><pre><span style="color: teal;">  1</span> powershell.exe -command -<span style="color: #2b91af;">set-executionpolicy</span> unrestricted   </pre><br /></div><div>Follow that up with a call to restore the Thrift NuGet package we included in the Visual Studio Project.<br /><br /></div><div><pre><span style="color: teal;">  1</span> nuget.exe -restore .\src\ThriftInterface.sln</pre><br /></div><div>This call will ensure that we have the compiler and thrift core dll on hand for the code generation and build steps. &nbsp;With everything in place we can call out code generation script and follow that with the Nant build.<br /><br /></div><div><pre><span style="color: teal;">  1</span> .\src\CodeGeneration\CodeGen.ps1 </pre><br /><pre></pre></div><div>Assuming compilation success we can add a post build task to run our NuGet packaging script.<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-Nui9a7M0oKM/U1xMucveXJI/AAAAAAAAASc/22pxsb0qsyw/s1600/SnipImage+copy.JPG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://3.bp.blogspot.com/-Nui9a7M0oKM/U1xMucveXJI/AAAAAAAAASc/22pxsb0qsyw/s1600/SnipImage+copy.JPG" height="276" width="640" /></a></div><br /><div>Again we need to set the environment execution policy to unrestricted.<br /><br /></div><div><pre><span style="color: teal;">  1</span> powershell.exe -command -<span style="color: #2b91af;">set-executionpolicy</span> unrestricted  </pre><br /></div><div>And finally call our NuGet packaging script.<br /><br /></div><div><pre><span style="color: teal;">  1</span> .\deployment_scripts\nuget_package.ps1</pre><br /></div><div>With everything set up, save the configuration, scroll back to the top of your Jenkin job, and press the magical "<i>build now</i>" button. &nbsp;With luck on your side you should be able to browse your NuGet server and see your new package.<br /><br />There will likely be an upcoming post that builds upon this one, delving into creating a Linq provider on top of the HBase thrift lib generated here. &nbsp;Feel free to comment here or ping me on Twitter&nbsp;<a href="https://twitter.com/williamberryiii" target="_blank">@williamberryiii</a> with questions.</div></div>