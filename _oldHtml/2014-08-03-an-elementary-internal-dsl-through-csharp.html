---
layout: post
title: An Elementary Internal Domain Specific Language (DSL) Using C# Extension Methods
date: '2014-08-03T15:51:00.002-07:00'
author: William Berry
tags:
- Domain Specific Language
- Option Types
- C#
- Extension Methods
- DSL
modified_time: '2014-08-03T17:21:51.286-07:00'
blogger_id: tag:blogger.com,1999:blog-4707687462195457004.post-4635218565630516845
blogger_orig_url: http://www.lucidmotions.net/2014/08/an-elementary-internal-dsl-through-csharp.html
---

A few weeks ago I had the opportunity to execute a small business rules engine for a client feature request that was done as an internal Domain Specific Language (DSL). &nbsp;The novel aspect of the project for me was not the harnessing of extension methods; that, while not elementary, was trivial compared to the application of functional design/programing, specifically compositional concepts. &nbsp;The resulting product was a terse, highly readable module that demonstrated the ability to fold functional approaches into an object oriented language and architecture. &nbsp;Most importantly however, this project marked my first real "Ah Ha" moment with functional programing &amp; design approaches.<br /><br /><div style="text-align: center;">***</div><br />From the applications perspective the interface into the rules engine was simple ... hand over the rules, hand over the things to run through the rules and then get back one or more applicable rules as the result. &nbsp;Each rule consisted of several operations that needed to be validated to see if the rule applied. &nbsp;For instance: start date, end date, minimum and maximum count, object selector. &nbsp;By all accounts, a clearer case for an internal DSL could not be found.<br /><br />The first question I asked myself was what do I want this DSL to look like? &nbsp;Since, C# provides extension methods, which can be an enabler of building fluent internal DSLs, they seemed like a likely candidate; a few rounds of pseudo-coding later, I had something like this:<br /><br /><div><!-- HTML generated using hilite.me --><br /><div style="background: #ffffff; border-width: .1em .1em .1em .8em; border: solid gray; overflow: auto; padding: .2em .6em; width: auto;"><table><tbody><tr><td><pre style="line-height: 125%; margin: 0;"> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11</pre></td><td><pre style="line-height: 125%; margin: 0;"><span style="color: #008800; font-weight: bold;">foreach</span>(<span style="color: #333399; font-weight: bold;">var</span> rule <span style="color: #008800; font-weight: bold;">in</span> rules){<br />    <span style="color: #008800; font-weight: bold;">foreach</span>(<span style="color: #333399; font-weight: bold;">var</span> obj <span style="color: #008800; font-weight: bold;">in</span> objects){<br />        <span style="color: #008800; font-weight: bold;">return</span> rule.HasTargetId(obj.id)<br />            .AfterStartDate(obj.date)<br />            .BeforeEndDate(obj.date)<br />            .LessThanMax(obj.count)<br />            .GreaterThanMin(obj.count) != <span style="color: #008800; font-weight: bold;">null</span><br />            ? rule<br />            : <span style="color: #008800; font-weight: bold;">null</span>;<br />    }<br />}<br /></pre></td></tr></tbody></table></div></div><br />Readable, terse and easily extended notion - UNLOCKED.<br /><br />With pseudo-code in hand, I began to work on the component architecture. &nbsp;Since one of the core tenants of FP is to segregate data and behavior, I framed out a few classes: the rules engine, a static class to house all the rule operations, and a few data type classes to model rules and the objects to pass through the rules.<br /><br />The design of the rules engine class is very simple with only one constructor and one method. &nbsp;The constructor takes in a set of rules as a dependency, building a readonly enumerable to hold the rules. &nbsp;The single method, takes in a set of objects, pushes those into the local projection, and runs the rules returning a list of matched rule. <br /><br />The extension methods, housed in the static class, encapsulate the behavior on our data, and are equally as simple and the rules engine. &nbsp;Let's take a look at one of them:<br /><div><!-- HTML generated using hilite.me --><br /><div style="background: #ffffff; border-width: .1em .1em .1em .8em; border: solid gray; overflow: auto; padding: .2em .6em; width: auto;"><table><tbody><tr><td><pre style="line-height: 125%; margin: 0;">1<br />2<br />3<br />4</pre></td><td><pre style="line-height: 125%; margin: 0;"><span style="color: #008800; font-weight: bold;">public</span> <span style="color: #008800; font-weight: bold;">static</span> Rule <span style="color: #0066bb; font-weight: bold;">LessThanMax</span>(<span style="color: #008800; font-weight: bold;">this</span> Rule rule, <span style="color: #333399; font-weight: bold;">int</span> objectCount){<br />    <span style="color: #008800; font-weight: bold;">if</span>(policy == <span style="color: #008800; font-weight: bold;">null</span>) <span style="color: #008800; font-weight: bold;">return</span> <span style="color: #008800; font-weight: bold;">null</span>;<br />    <span style="color: #008800; font-weight: bold;">return</span> objectCount &lt; rule.MaxCount ? rule : <span style="color: #008800; font-weight: bold;">null</span>;<br />}<br /></pre></td></tr></tbody></table></div></div><br />The basic premise here is, if we pass in a null rule then the extension method simply returns null to the next method in the chain. &nbsp;If the rule is not null then we check the rule and object arguments, either passing the rule or null along to the next method. <br /><br />While all these nulls floating around is not very pretty, it does get the job done; given that though, it may be preferable to create default instances of your rule(s) with sane values and pass that through in place of the nulls.<br /><br />And that's it ... a simple internal DSL that leverages extension methods, composition, segregation of data and behavior to facilitate an easy to reason about rules engine. &nbsp;Most importantly ... no nasty nested "if" statements!<br /><br />For further study, I would highly suggest watching <a href="https://twitter.com/ScottWlaschin">Scott Wlaschin</a>'s <a href="http://vimeo.com/97344498">Railway Oriented Programming</a> talk to get some ideas about how you could weave in error handling; or checkout <a href="https://twitter.com/tomaspetricek">Tomas Petricek</a> &amp; <a href="https://twitter.com/jonskeet">Jon Skeet</a>'s <a href="http://www.manning.com/petricek/">Real World Functional Programming</a> book ... in chapter 5 they cover an implementation of Option Types in C# which would dramatically enhance the naive implementation above.<br /><br />As always, I would appreciate comments, corrections or feedback!<br /><br />