---
layout: post
title: Timing Method Execution in C#
date: '2015-09-27T22:47:00.001-07:00'
author: William Berry
tags:
- Performance Monitoring
- C#
modified_time: '2015-09-27T22:53:21.326-07:00'
blogger_id: tag:blogger.com,1999:blog-4707687462195457004.post-7239784770276903771
blogger_orig_url: http://www.lucidmotions.net/2015/09/timing-method-execution-in-csharp.html
---

An awesome tweet from Jessica Kerr rolled by this morning in quite a timely fashion.<br /><br /><blockquote class="twitter-tweet" lang="en"><p lang="en" dir="ltr">To scale the rate of feature development, you have to constantly be working on your monitoring and automation.&#10;<a href="https://twitter.com/skamille">@skamille</a> <a href="https://twitter.com/hashtag/strangeloop?src=hash">#strangeloop</a></p>&mdash; Jessica Kerr (@jessitron) <a href="https://twitter.com/jessitron/status/647787930442932224">September 26, 2015</a></blockquote><script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script><br />I've been working hard for the last few days to really dial up the instrumentation and telemetry data collection in our primary transaction processing application. &nbsp;We've always had a sufficient view into the operational characteristics of the application, but like the tweet above notes, the faster we want to move, the more data we need to collect. <br /><br />Given that instrumenting a mature application can be difficult at best and resisting the urge to perform a heavy refactoring is even harder, I've struggled to keep the surface area of change as small as possible. <br /><br />Throughout this work, the Siren's Call of rip and rewrite has been the most powerful in our data access code. &nbsp;Like most n-tier apps, we have a flat layer of code that's wedged &nbsp;between the business logic for transaction processing and the database, with all interactions flowing through just a handful of objects. &nbsp;Though this architectural approach has fallen out of favor with me and begs to be changed, we must sometimes take the short road to higher ground and clean things up after building some space for reflection. <br /><br />My primary objective with this segment of the project was to add timing code around all the stored procedure calls. &nbsp;Some of this timing data will be sent to windows performance counters, others bulk logged into HBase on our Hadoop cluster and others still, aggregated and recorded in our SQL Server logging tables, which record at the transaction level. <br /><br />The approach here is oriented around triage and batch analytics. &nbsp;With performance counters we can quickly see, in near real-time, how sections of db calls are behaving. &nbsp;We can then turn to SQL server to collect transaction profiles exhibiting higher latency and debug them in our development environment. &nbsp;Lastly, we can get both audit functionality and custom performance analysis by writing analytics jobs on the cluster that encompass longer time frames. <br /><br />The following Gist is a simple example repository. &nbsp;The repository has a small wrapper class which helps deal with SqlHelper exceptions and a connection string which are injected to improve testability. &nbsp;Additionally, we have a simple method which will return a 'thingy' from the database given a thingy_id. <br /><br /><script src="https://gist.github.com/WilliamBerryiii/a01da8b9f53732bad4b4.js"></script> As I noted above, the goal is to instrument this method, timing the length of the stored procedure call. &nbsp;The easy way out would be some local state in the class and a standard .Net stopwatch. &nbsp;I don't have any particular problem with that approach, in fact it's where I started, but the main drawback is the verbosity. &nbsp;Every method would end up looking like this:<br /><br /><script src="https://gist.github.com/WilliamBerryiii/b99e6aceb25f31a380f8.js"></script> Again the approach is not bad, per se, but it is verbose and repetitive if every method needs this change, which in this case we do. <br /><br />At the other extreme, we could use Aspect Oriented Programming with attributing and IL weaving to inject our instrumentation code around our methods. &nbsp;The .Net library exemplar for this is <a href="https://www.postsharp.net/aspects">PostSharp</a> with it's compile time AOP capabilities. &nbsp;Amazing technology, but given that we are still trying to figure out what we really need from all this, I'd prefer a happy medium. <br /><br />So what I ended up with was the following:<br /><br /><script src="https://gist.github.com/WilliamBerryiii/d444f262444eb8e05249.js"></script><br />I've added a public property with a backing field that will be used to extract the timing data from our repository class - nothing special there. &nbsp;Skipping over our data access method for a moment there is a new method at the bottom of the repository that will do our timing. <br /><br />The timing method takes two parameters, a func that returns a DataSet and a ref to our timing field. &nbsp;Since we are pre-filling our method parameters, the timer function leverages the func(TResult) signature, getting some nice flexibility from the type system. &nbsp;The ref timing field will be incremented using the Interlocked API so that we can handle some modest concurrency in the repository. &nbsp;Otherwise, the method looks like an extract of the "simple" approach with a stopwatch. <br /><br />Back up in the data access method the Sql Executioner, wrapped in a lambda, and the timing field are passed to the Timer method and the remainder of the method is left nominally unchanged.<br /><br />This simple approach to timing method calls can be used with a fair amount of flexibility throughout an application. &nbsp;Consider overloading the timer with an action delegate too, for even more flexibility ... happy coding!<br />&nbsp; &nbsp; <br />P.S. the following link goes to an interesting set of answers to this very problem on Stack Overflow: <a href="http://stackoverflow.com/questions/232848/wrapping-stopwatch-timing-with-a-delegate-or-lambda">wrapping stopwatch timing with a delegate or lambda</a>.<br /><br />