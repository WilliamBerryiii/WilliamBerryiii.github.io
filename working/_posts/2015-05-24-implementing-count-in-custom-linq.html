---
layout: post
title: Implementing $Count in a Custom Linq Provider with WebAPI OData v4
date: '2015-05-24T17:43:00.004-07:00'
author: William Berry
tags:
- OData
- Solr
- C#
- C# NoSql
- LINQ
- WebAPI
modified_time: '2015-05-30T22:43:17.198-07:00'
blogger_id: tag:blogger.com,1999:blog-4707687462195457004.post-1465436280772497672
blogger_orig_url: http://www.lucidmotions.net/2015/05/implementing-count-in-custom-linq.html
---

Over the last week I have been working on implementing a custom Linq provider that wraps a Solr search query and returns a composite projection of the solr search results and some underlying Hbase data. &nbsp;Just to add to the madness, the composite projection is a child element of a WebAPI endpoint and is made query-able via Odata.<br /><br />Before we can get to what this post is really about, implementing $count from the OData spec, we need to get familiar with all the moving pieces. &nbsp;At the core, is the implementation of IQueryable or IOrderedQueryable if you need ordered results sets. &nbsp;This queryable implementation takes a provider that consumes a context that handles all the parsing logic and mapping down to whatever service wrapper you are implementing for. &nbsp;Throw in a few dozen classes to handle expression parsing, give yourself a week and boom you have a functioning IQueryable. &nbsp;Then you turn on OData, wire up your controller and drop some code that looks like this:<br /><br /><pre style="background-color: white; margin: 0em; overflow: auto;"><code style="color: black; font-family: Consolas,&quot;Courier New&quot;,Courier,Monospace; font-size: 10pt;"><span style="color: blue;">var</span> foo = <span style="color: blue;">new</span> QueryableData&lt;Bar&gt;(_provider);<br /><span style="color: blue;">var</span> result = (IQueryable&lt;Bar&gt;)queryOptions.ApplyTo(foo);<br /><br /><span style="color: blue;">return</span> <span style="color: blue;">new</span> PageResult&lt;Bar&gt;(result.ToList(), <span style="color: blue;">null</span>, _provider.Count);</code></pre><br />The provider is injected into the controller, passed to the QueryableData source, the OData QueryOptions are applied to the IQueryable and we return the result as a paged data set. &nbsp;Boom. Slap some $count=true on the end of your urls and Done...<br /><br />Not so fast.<br /><br />I ran my code with a unit test to see what the $count was going to do. &nbsp;Unexpectedly, I encountered <i>'cannot convert IQueryable&lt;Bar&gt; to type long'</i> which had me a bit puzzled. &nbsp;I had presumed that the count would turn out to be an expression that needed to be teased from the tree but in this case it appeared to be wrapping the entire tree - the debugger confirmed as much. &nbsp;As a test, I reversed my logic of passing the count back as an accessory property up the chain to passing the queryable as the accessory and the count of results as the primary return type. &nbsp;Running the unit test again resulted in yet another confusing error - <i>'cannot convert type long to IQueryable&lt;Bar&gt;'</i>. WTF?<br /><br />I reset my breakpoints and stepped through the code again finding a rather cleaver thing. &nbsp;My expression parser was actually being called <i>twice</i>. &nbsp;Once with the LongCout expression wrapper and then again without it. &nbsp;A small change to my provider's execute method yielded the correct results:<br /><br /><pre style="background-color: white; margin: 0em; overflow: auto;"><code style="color: black; font-family: Consolas,&quot;Courier New&quot;,Courier,Monospace; font-size: 10pt;"><span style="color: blue;">if</span> (Queryable == <span style="color: blue;">null</span>)<br />{<br />    <span style="color: blue;">var</span> isEnumerable = (<span style="color: blue;">typeof</span>(TResult).Name == <span style="color: #a31515;">"IEnumerable`1"</span> || <span style="color: blue;">typeof</span>(TResult).Name == <span style="color: #a31515;">"Int64"</span>);<br />    <span style="color: blue;">var</span> result = _serviceWrapperContext.Execute(expression, isEnumerable);<br /><br />    <span style="color: green;">// we dont have a count to contend with so just return the queryable</span><br />    <span style="color: blue;">if</span> (result.GetType() != <span style="color: blue;">typeof</span>(QueryableCountWrapper))<br />        <span style="color: blue;">return</span> (TResult)result;<br /><br />    <span style="color: blue;">var</span> r = (QueryableCountWrapper)result;<br />    <span style="color: green;">// Is our expression wrapped with a count query? </span><br />    <span style="color: blue;">if</span> (<span style="color: blue;">typeof</span>(TResult).Name == <span style="color: #a31515;">"Int64"</span>)<br />    {<br />        Queryable = r.Queryable;<br />        <span style="color: blue;">return</span> (TResult)r.Count;<br />    }<br /><br />    Count = Int64.Parse(r.Count.ToString());<br />}<br /><span style="color: blue;">return</span> (TResult)Queryable;</code></pre><br />Since the provider is an injected dependency of the controller with a per request life time, I am able to use it as a cache of sorts. &nbsp;The first time through the execute method we will call our service wrapper context to have the query parsed, compiled and executed. &nbsp;If we have a wrapping LongCount expression then the results will come back from the service wrapper bundled in a <i>QueryableCountWrapper</i>. &nbsp;We can then unpack the <i>QueryableCountWrapper</i> into class properties, and with a bit of switching logic prevent a double execution of the service wrapper calls.<br /><br />Hope this saves someone some time in the future and happy coding.<br /><br /><br />